<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>3D Game Template 8</title>
  <style>
    html,body{height:100%;margin:0;background:#071022;color:#fff;overflow:hidden;font-family:Inter,Arial,Helvetica,sans-serif}
    #ui{position:fixed;left:12px;top:12px;z-index:10}
    .btn{background:#06b6d4;color:#001f26;padding:8px 10px;border-radius:8px;border:none;cursor:pointer;font-weight:700}
    #score{margin-left:12px;font-weight:600}
    #hint{position:fixed;right:12px;top:12px;background:rgba(0,0,0,0.35);padding:8px;border-radius:8px}
  </style>
</head>
<body>
<div id="ui"><button id="restart" class="btn">Yeniden Başlat</button><span id="score">Puan: 0</span></div>
<div id="hint">Bu bir 3D şablondur — dosyayı düzenleyerek oyun mantığını geliştirebilirsin.</div>
<script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.155.0/examples/js/controls/OrbitControls.js"></script>
<h2 style='position:fixed;left:12px;top:56px;margin:0;padding:6px 10px;background:rgba(0,0,0,0.35);border-radius:8px'>3D Game Template 8</h2>
<script>

// Basic Three.js 3D game template (auto-generated)
// Scene, camera, renderer
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x071022, 0.002);
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 10, 18);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// controls (for debug / rotating view)
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.enablePan = false;
controls.minDistance = 5;
controls.maxDistance = 60;

// lights
const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff, 0.6);
dir.position.set(5,10,7);
scene.add(dir);

// ground
const groundGeo = new THREE.PlaneGeometry(200,200);
const groundMat = new THREE.MeshStandardMaterial({color:0x042027, roughness:0.9, metalness:0.1});
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI/2;
ground.position.y = -0.5;
scene.add(ground);

// player (sphere)
const playerGeo = new THREE.SphereGeometry(2.4, 24, 24);
const playerMat = new THREE.MeshStandardMaterial({color:0x34d399, metalness:0.2, roughness:0.4});
const player = new THREE.Mesh(playerGeo, playerMat);
player.position.set(0, 2.4+0.2, 0);
scene.add(player);

// obstacles (boxes)
let obstacles = [];
function makeObstacles(n){
  for(let i=0;i<n;i++){
    const g = new THREE.BoxGeometry(2.0, 2.2, 3.8);
    const m = new THREE.MeshStandardMaterial({color:0xf59e0b});
    const box = new THREE.Mesh(g,m);
    const x = (Math.random()-0.5)*60;
    const z = -Math.random()*400;
    box.position.set(x, 2.2/2 - 0.5, z);
    scene.add(box); obstacles.push(box);
  }
}
makeObstacles(13);

// simple physics
let velocity = new THREE.Vector3(0,0,0);
const gravity = -20;
const speed = 8;

// input
const keys = {};
window.addEventListener('keydown', e=>keys[e.key.toLowerCase()]=true);
window.addEventListener('keyup', e=>keys[e.key.toLowerCase()]=false);

let score = 0;
function updateScore(){ document.getElementById('score').textContent = 'Puan: '+Math.floor(score); }

document.getElementById('restart').onclick = ()=>{ restart(); };

function restart(){
  // reset player and obstacles
  player.position.set(0, 2.4+0.2, 0);
  velocity.set(0,0,0);
  for(let i=0;i<obstacles.length;i++){
    obstacles[i].position.z = -Math.random()*400;
    obstacles[i].position.x = (Math.random()-0.5)*60;
  }
  score = 0;
  updateScore();
}

let last = performance.now();
function animate(now){
  const dt = Math.min(0.05, (now - last)/1000);
  last = now;
  // inputs - left/right
  if(keys['arrowleft'] || keys['a']) player.position.x -= speed*dt;
  if(keys['arrowright'] || keys['d']) player.position.x += speed*dt;
  // forward auto-run
  player.position.z -= speed*dt*3;
  // gravity
  velocity.y += gravity*dt;
  player.position.y += velocity.y*dt;
  if(player.position.y < 2.4+0.2){ player.position.y = 2.4+0.2; velocity.y = 0; }
  // jump
  if((keys[' '] || keys['arrowup'] || keys['w']) && player.position.y <= 2.4+0.25){ velocity.y = 8; }
  // move obstacles towards player and recycle
  for(let i=0;i<obstacles.length;i++){
    const o = obstacles[i];
    o.position.z += speed*dt*3;
    if(o.position.z > 10){ o.position.z = -Math.random()*400; o.position.x = (Math.random()-0.5)*60; }
    // simple collision test
    const dx = Math.abs(o.position.x - player.position.x);
    const dz = Math.abs(o.position.z - player.position.z);
    const collide = dx < (2.0/2 + 2.4) && dz < (3.8/2 + PL_R);
    if(collide){
      // collision effect: push player back and deduct score
      player.position.z += 6;
      score = Math.max(0, score - 5);
      updateScore();
    } else {
      // if player passed obstacle, add point
      if(o.userData.passed !== true && o.position.z > player.position.z){
        o.userData.passed = true; score += 1; updateScore();
      }
      if(o.position.z <= player.position.z) o.userData.passed = false;
    }
  }
  // camera follow
  camera.position.lerp(new THREE.Vector3(player.position.x, player.position.y + 8, player.position.z + 18), 0.08);
  camera.lookAt(player.position.x, player.position.y, player.position.z - 6);
  controls.update();
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

</script>

</body>
</html>
